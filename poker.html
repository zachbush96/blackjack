<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Poker 1.1</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            background-color: #2c3e50;
            color: white;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        .card {
            display: inline-block;
            width: 60px;
            height: 90px;
            margin: 10px;
            border: 1px solid #ecf0f1;
            line-height: 90px;
            font-size: 24px;
            background-color: #34495e;
            transition: all 0.3s ease;
            user-select: none;
        }
        .held {
            border: 3px solid #e74c3c;
        }
        .winning {
            border: 3px solid #2ecc71;
        }
        .replaced {
            animation: cardReplace .5s ease;
        }
        @keyframes cardReplaceBackup {
            0% { transform: rotateY(0deg) perspective(600px); }
            50% { transform: rotateY(90deg) perspective(600px) rotateX(10deg); }
            100% { transform: rotateY(0deg) perspective(600px); }
        }
                @keyframes cardReplace {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0deg); }
        }

        #bankroll {
            font-size: 4vw;
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            margin: 10px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background: linear-gradient(45deg, #3498db, #2ecc71);
            color: white;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            max-width: 100%;
            width: 40vw;
        }
		button:disabled {
			/* Remove the background gradient */
			background: none;
			/* Set the text color to white */
			color: white;
		}
        
    </style>
</head>
<body>
    <h1>Video Poker 1.2</h1>
    <div id="bankroll">Bankroll: $100</div>
    <div id="resultsMessage"></div>
		<div id="gameRules">
			<h2>Game Rules</h2>
			<div>
		    <strong>Poker Payouts:</strong><br>
		    Royal Flush: $250<br>
		    Straight Flush: $50<br>
		    Four of a Kind: $25<br>
		    Full House: $9<br>
		    Flush: $6<br>
		    Straight: $4<br>
		    Three of a Kind: $3<br>
		    Two Pair: $2<br>
		    Jacks or Better: $1<br>
		    No Win: -1
			</div>
		</div>
    <div id="cards">
        <div class="card" data-index="0">?</div>
        <div class="card" data-index="1">?</div>
        <div class="card" data-index="2">?</div>
        <div class="card" data-index="3">?</div>
        <div class="card" data-index="4">?</div>
    </div>
    <div>
        <button id="deal-button">Deal</button>
        <button id="draw-button" disabled>Draw</button>
        <button id="reset-button">Reset</button>
    </div>
    <script>
let deck = [];
let playerHand = [];
let heldCards = [false, false, false, false, false];
let bankroll = 100;
let gameState = 'deal';
			
let resultMessage = document.getElementById('resultsMessage');
const cardElements = document.querySelectorAll('.card');
const dealButton = document.getElementById('deal-button');
const drawButton = document.getElementById('draw-button');
const resetButton = document.getElementById('reset-button');
const bankrollElement = document.getElementById('bankroll');

const paytable = {
    "Royal Flush": 250,
    "Straight Flush": 50,
    "Four of a Kind": 25,
    "Full House": 9,
    "Flush": 6,
    "Straight": 4,
    "Three of a Kind": 3,
    "Two Pair": 2,
    "Jacks or Better": 1,
    "No Win": -1
};


cardElements.forEach((card, index) => {
    card.addEventListener('click', () => {
        heldCards[index] = !heldCards[index];
        updateDisplay();
    });

    // Add touch event for mobile devices
    card.addEventListener('touchstart', () => {
        heldCards[index] = !heldCards[index];
        updateDisplay();
    })
})


function updateResultsMessage(message) {
	resultMessage.textContent = message;
}

			
function createDeck() {
    const suits = ['♠', '♥', '♦', '♣'];
    const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    deck = [];

    for (let suit of suits) {
        for (let value of values) {
            deck.push({ value, suit });
        }
    }

    deck.sort(() => Math.random() - 0.5);
}

function dealCards() {
    // if there is a message, clear it
		updateResultsMessage(" ");
		playerHand = deck.splice(0, 5);
    heldCards = [false, false, false, false, false];
    updateDisplay();
    gameState = 'draw';
}

function updateDisplay() {
    for (let i = 0; i < 5; i++) {
        const card = playerHand[i];
        cardElements[i].textContent = `${card.value}${card.suit}`;
        cardElements[i].classList.toggle('held', heldCards[i]);
        //cardElements[i].classList.remove('winning', 'replaced');
        cardElements[i].classList.remove('winning');
    }
    bankrollElement.textContent = `Bankroll: $${bankroll}`;
}

document.addEventListener('keydown', (e) => {
    const key = e.key;
    if (key >= '1' && key <= '5') {
        const index = parseInt(key) - 1;
        heldCards[index] = !heldCards[index];
        updateDisplay();
    } else if (key === 'Enter') {
        handleEnterKeyPress();
    }
});

function handleEnterKeyPress() {
    console.log("Enter Key Pressed");
		if (gameState === 'deal') {
        dealButton.click();
    } else if (gameState === 'draw') {
        drawButton.click();
    }
}

dealButton.addEventListener('click', () => {
    createDeck();
    dealCards();
    dealButton.disabled = true;
    drawButton.disabled = false;
    gameState = 'draw';
});

drawButton.addEventListener('click', () => {
    for (let i = 0; i < 5; i++) {
        if (!heldCards[i]) {
            playerHand[i] = deck.pop();
            cardElements[i].classList.remove('replaced'); // Remove and re-add to restart the animation
            void cardElements[i].offsetWidth; // Trigger a reflow to restart the animation
            cardElements[i].classList.add('replaced');
        }
    }
    updateDisplay();
    drawButton.disabled = true;
    evaluateHand();
    gameState = 'deal';
});

resetButton.addEventListener('click', () => {
    bankroll = 100;
    dealButton.disabled = false;
    drawButton.disabled = true;
    bankrollElement.textContent = `Bankroll: $${bankroll}`;
    cardElements.forEach(card => {
        card.textContent = '?';
        card.classList.remove('held', 'winning', 'replaced');
    });
    gameState = 'deal';
});

function evaluateHand() {
    const { handRank, winningIndices } = getHandRank(playerHand);
    const payout = paytable[handRank] || 0;
    bankroll += payout;
    bankrollElement.textContent = `Bankroll: $${bankroll}`;
    //alert(`Hand: ${handRank} | Payout: $${payout}`);
		updateResultsMessage(`Hand: ${handRank} | Payout: $${payout}`);
    highlightWinningCards(winningIndices);
    dealButton.disabled = false;
}

function getHandRank(hand) {
    const values = hand.map(card => card.value);
    const suits = hand.map(card => card.suit);
    const valueCounts = {};
    const suitCounts = {};
    
    values.forEach(value => {
        valueCounts[value] = (valueCounts[value] || 0) + 1;
    });
    suits.forEach(suit => {
        suitCounts[suit] = (suitCounts[suit] || 0) + 1;
    });
    
    const valueCountArray = Object.values(valueCounts);
    const isFlush = Object.keys(suitCounts).length === 1;
    const isStraight = isSequential(values);
    
    if (isFlush && isStraight && values.includes('A') && values.includes('K')) 
        return { handRank: "Royal Flush", winningIndices: [0, 1, 2, 3, 4] };
    if (isFlush && isStraight) 
        return { handRank: "Straight Flush", winningIndices: [0, 1, 2, 3, 4] };
    if (valueCountArray.includes(4)) {
        const fourOfAKindValue = Object.keys(valueCounts).find(key => valueCounts[key] === 4);
        return { handRank: "Four of a Kind", winningIndices: values.map((v, i) => v === fourOfAKindValue ? i : -1).filter(i => i !== -1) };
    }
    if (valueCountArray.includes(3) && valueCountArray.includes(2)) 
        return { handRank: "Full House", winningIndices: [0, 1, 2, 3, 4] };
    if (isFlush) 
        return { handRank: "Flush", winningIndices: [0, 1, 2, 3, 4] };
    if (isStraight) 
        return { handRank: "Straight", winningIndices: [0, 1, 2, 3, 4] };
    if (valueCountArray.includes(3)) {
        const threeOfAKindValue = Object.keys(valueCounts).find(key => valueCounts[key] === 3);
        return { handRank: "Three of a Kind", winningIndices: values.map((v, i) => v === threeOfAKindValue ? i : -1).filter(i => i !== -1) };
    }
    if (valueCountArray.filter(count => count === 2).length === 2) {
        const pairValues = Object.keys(valueCounts).filter(key => valueCounts[key] === 2);
        return { handRank: "Two Pair", winningIndices: values.map((v, i) => pairValues.includes(v) ? i : -1).filter(i => i !== -1) };
    }
    if (valueCountArray.includes(2)) {
        const pairValue = Object.keys(valueCounts).find(key => valueCounts[key] === 2);
        if (['J', 'Q', 'K', 'A'].includes(pairValue)) {
            return { handRank: "Jacks or Better", winningIndices: values.map((v, i) => v === pairValue ? i : -1).filter(i => i !== -1) };
        }
    }
    
    return { handRank: "No Win", winningIndices: [] };
}


function isSequential(values) {
    const valueOrder = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'];
    const sortedValues = values.slice().sort((a, b) => valueOrder.indexOf(a) - valueOrder.indexOf(b));
    for (let i = 0; i < sortedValues.length - 1; i++) {
        if (valueOrder.indexOf(sortedValues[i + 1]) - valueOrder.indexOf(sortedValues[i]) !== 1) {
            return false;
        }
    }
    return true;
}

function hasJacksOrBetter(values) {
    return values.includes('J') || values.includes('Q') || values.includes('K') || values.includes('A');
}

function highlightWinningCards(indices) {
    indices.forEach(index => {
        cardElements[index].classList.add('winning');
    });
}

    </script>
</body>
</html>
